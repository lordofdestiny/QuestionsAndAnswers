#pragma once
#include <string>
#include <utility>

namespace qna {
	enum class EPostType { Comment, Answer, Question };
	class Post
	{
	public:
		Post(std::string comment, EPostType type = EPostType::Comment) :
			_text(comment), _type(type), _id(_nextId++) {}
		Post(Post const& rhs) :
			_type(rhs._type), _text(rhs._text),
			_score(rhs._score), _id(_nextId++) {};
		Post(Post&& rhs) noexcept :
			_type(rhs._type), _text(std::move(rhs._text)),
			_score(rhs._score), _id(rhs._id) {}
		Post& operator=(Post const& other)  {
			if (this != &other) {
				_type = other._type;
				_text = other._text;
				_score = other._score;
				_id = _nextId++;
			}
			return *this;
		};
		Post& operator=(Post&& other) noexcept {
			if (this != &other) {
				_type = other._type;
				_text = std::move(other._text);
				_score = other._score;
				_id = other._id;
			}
			return *this;
		}

		unsigned upvote() {
			return ++_score;
		}

		unsigned downvote() {
			return --_score;
		}

		unsigned votes() const {
			return _score;
		}
		
		unsigned long id() const {
			return _id;
		}

		std::string const& text() const {
			return _text;
		}

		std::string const& update(std::string newText) {
			return _text = newText;
		}

		EPostType type() const {
			return _type;
		}
	private:
		static inline unsigned long _nextId = 0;
		EPostType _type = EPostType::Comment;
		std::string _text = "Autogenerated.";
		unsigned _score = 0;
		unsigned long _id;
	};


}
